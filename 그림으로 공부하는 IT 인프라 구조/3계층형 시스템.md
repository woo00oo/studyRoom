### 프로세스와 쓰레드

프로세스와 쓰레드는 프로그램 실행 파일 자체가 아니라 OS상에서 실행돼서 어느 정도 독립성을 가지고 동작하는 것이다.
프로세스 및 쓰레드가 활동하려면 메모리 공간이 필요하다. 이것은 커널에 의해 메모리상에 확보된다. 이 메모리 공간을 통하여 다양한 처리를 하면서 데이터를 주고받을 수 있다.

프로세스와 쓰레드의 가장 큰 차이점은 각 프로세스는 독립된 메모리 공간을 가지고 있지만 하나의 프로세스안에 있는 여러 쓰레드들은 메모리 공간을 공유하는 점이다.

프로세스와 쓰레드 중에 어떤 것을 이용할지는 애플리케이션 개발자가 정한다. 이때 각각의 특성을 이해하고 설계와 프로그래밍할 필요가 있다.

##### 프로세스와 쓰레드 비교

|   |  프로세스  |  쓰레드 |
| --- | --- | ----|
|장점 | 개별 처리 독립성이 높다 | 생성 시 부하가 낮다 |
|단점 | 생성 시 CPU 부하가 높다 | 메모리 공간을 공유하기 때문에 의도하지 않는 데이터 읽기/쓰기가 발생할 수 있다(동시성 이슈) |

##### 프로세스 메모리 공간 공유 (오라클 DB)

오라클 DB에서는 여러 프로세스가 '공유 메모리 공간'을 상호 이용할 수 있게 되어 있다.

1. 오라클 DB에서는 각 프로세스별 메모리 공간(PGA)과 프로세스 전체가 공유하는 메모리 공간(SGA)이 나누어져 있다.

2. 공유 메모리(SGA)에는 디스크상의 데이터 캐시나 실행 완료된 SQL 캐시, 테이블, 인덱스 등이 저장된다.

3. 프로세스별 메모리(PGA)에는 해당 프로세스 SQL이 이용하는 소트 영역이나 테이블 결합에 사용하는 메모리 영역이 저장돼 있다. 이 영역은 다른 프로세스가 접근할 수 없다. 이 메모리가 부족하면 공유 메모리를 아무리 크게 잡아도 효과를 볼 수 없다.

### OS 커널

OS에서 커널은 심장이자 뇌이며 척수다. 커널이 OS의 본질이며, 나머지는 그저 덤일 뿐이라고 해도 과언이 아니다. 커널 자체가 OS의 '인프라'라고 생각하면 된다.
커널은 다양한 역할을 갖지만, 가장 중요한 것은 '**뒤에서 무슨 일이 벌어지는지 은폐하면서도 편리한 인터페이스를 제공하는 것**'이다. 이렇듯 커널이 존재하기 때문에 개발자는 하드웨어나 다른 애플리케이션에 끼치는 영향을 의식하지 않고 애플리케이션을 만들 수 있다.


- 시스템 콜 인터페이스

    > 프로세스/쓰레드에서 커널로 연결되는 인터페이스
    
    애플리케이션이 OS를 통해서 어떤 처리를 하고 싶으면 **시스템 콜**이라고 하는 명령을 이용해서 커널에 명령을 내린다. 이때 명령이 인터페이스를 통해서 전달된다.
    
    ex) 디스크상의 데이터를 읽고 싶거나 네트워크 통신을 하고 싶을때, 또는 새로운 프로세스를 생성하고 싶은 경우에 해당 시스템 콜을 호출하면 기능을 이용할 수 있다.
    

- 프로세스 관리

    OS상에서는 수십, 수백, 수천 개의 프로세스를 가동할 수 있다. 이에 비해 물리 서버의 CPU 코어 수는 많아야 수십개 정도밖에 안 된다.
    언제, 어떤 프로세스가 어느 정도의 CPU 코어를 이용할 수 있는지, 처리 우선순위를 어떻게 결정할 것인지 등을 관리하는 것이 이 기능의 역할이다.

- 메모리 관리

    프로세스 관리는 CPU 코어를 고려했지만, 메모리 관리에서는 물리 메모리 공간의 최대치를 고려한다. 프로세스가 이용하는 독립 메모리 공간을 확보하거나 상호 간의 참조 영역을 지키기 위해 독립성을 관리하는 등의 메모리 관리 역할을 한다.
 
- 네트워크 스택

- 파일 시스템 관리

    > 파일 시스템용 인터페이스를 제공한다.
             
   파일 시스템은 OS 기능의 하나로서 물리 디스크에 제공된 데이터를 관리하는 기능이다.
   
   ex) 일상에서 사용하는 '문서파일'이나 '엑셀 파일'이 파일에 해당한다. 물리 디스크에 기록된 데이터는 '01011110 ....'과 같은 숫자의 집합에 불과하다. 구분 표시도 없을뿐더러 그대로 사용하기는 매우 어려운 형태다.
   하지만 파일 시스템 덕분에 애플리케이션은 '파일'이라는 단위로 데이터를 작성하거나 삭제할 수 있다.
   
   주요 관리 기능으로는 디렉터리(폴더) 구조 제공, 액세스 관리, 고속화, 안정성 향상 등이 있다.
   


- 장치 드라이버

    > 디스크나 NIC 등의 물리 장치용 인터페이스를 제공한다.
    
    예를 들어, NIC나 디스크는 다수의 제조사가 독자 제품을 제공하고 있다. 각각에 대응하는 애플리케이션을 개발하는 것은 현실적이지 못하기 때문에 커널은 장치 드라이버를 이용해서 그 아래에 있는 물리 장치를 은폐한다.
    각 장치 제조사가 OS에 대등하는 장치 드라이버를 제공해서 해당 OS의 표준 장치로서 커널을 경유해 이용할 수 있게 하는 것이다.

### 웹 데이터 흐름

#### 클라이언트 PC부터 웹 서버까지

1. 웹 브라우저가 요청을 발행한다.

2. 이름 해석을 한다(DNS LookUp)

3. 웹 서버의 'httpd'프로세스가 요청을 접수한다.

4. 웹 서버가 정적 콘텐츠인지 동적 콘텐츠인지 판단한다.

5. 필요한 경로로 데이터에 액세스한다.

    - 정적인 정보는 디스크로부터 읽는다.
    
    > **정적 콘텐츠**란, 실시간으로 변경할 필요가 없는 데이터를 가리킨다. ex) 회사 로고 이미지등
     웹서버에서는 데이터 갱신 빈도가 낮은 정적 콘텐츠를 디스크에 저장해서 요청이 있으면 저장해둔 내용을 HTTP를 통해 사용자 웹 브라우저로 반환한다.
    
    - 동적인 정보는 네트워크를 경유해서 다른 서버에 요청을 보낸다. => AP 서버로
    
    > 동적 콘텐츠란, 높은 빈도로 변경되는 데이터를 가리킨다. ex) 사용자의 은행 잔고 정보, 최신 날씨 데이터등
     이런 데이터를 서버 내부의 디스크에 저장하면 갱신 빈도가 높기 때문에 디스크 성능이 병목현상의 원인이 될 수 있다.

#### 웹 서버부터 AP 서버(WAS)까지

1. 웹 서버로부터 요청이 도착한다.

2. 쓰레드가 요청을 받으면 자신이 계산할 수 있는지, 아니면 DB 접속이 필요한지를 판단한다.

    ex) 단순 요청(1+1계산 결과)은 애플리케이션상에서 계산하면 되기에 AP 서버의 담당 쓰레드가 계산한 후 결과를 반환
        
        '사용자 잔금 정보' 요청의 경우 AP서버에서 대량의 데이터들을 관리할 수 없기 때문에 AP 서버의 쓰레드는 DB 서버에 질의한다.

3. DB 접속이 필요하면 커넥션 풀에 액세스한다.

4. DB 서버에 요청을 던진다.


##### DB 서버 이외의 옵션

규모가 작고 갱신 빈도가 낮은 정보(대한민국 행정 경계 정보)같은 데이터는 데이터베이스에 질의할 필요 없이 JVM 내부 캐시로 저장해 두었다가 반환하는 것이 좋다.
반대로, 규모가 큰 정적 데이터 전송 시에는 DB 서버 이외에 CDN(Content Delivery Network)이라 불리는 데이터 전송 전용 서버를 이용하는 경우도 있다.

대부분의 웹 시스템에서 CDN을 이용하고 있다. 이것은 웹 시스템의 특징인 '하나의 시스템을 수많은 사용자가 이용한다', '대량의 데이터를 참조하는 업무가 많다'라는 것에 기인한다.
CDN은 대량의 데이터 전송에 특화된 것으로, 전 세계에 있는 데이터 복사본(캐시)을 배치하는 기술과 병렬 기술을 활용해서 처리를 효율화하고 있다.

#### AP 서버부터 DB서버까지

요청은 SQL이라는 언어 형태로 이루어진다.
이 SQL을 해석해서 데이터 액세스 방식을 결정하고, 디스크나 메모리에서 필요한 데이터만 수집해 오는 것이 데이터베이스의 주요 역할이다.

1. AP 서버로부터 요청이 도착한다.

2. 프로세스가 요청을 접수하고 캐시가 존재하는지 확인한다.

3. 캐시에 없으면 디스크에 액세스한다.

4. 디스크가 데이터를 반환한다.

5. 데이터를 캐시 형태로 저장한다.(이후 액세스 시에 재사용됨)

6. 결과를 AP 서버에 반환한다.

#### AP 서버부터 웹 서버까지

1. DB 서버로부터 데이터가 도착한다.

2. 쓰레드가 데이터를 가지고 계산 등을 한 후에 파일 데이터를 생성한다.

3. 결과를 웹 서버로 반환한다.

#### 웹 서버로부터 클라이언트 PC까지

1. AP 서버로부터 데이터가 도착한다.

2. 프로세스는 받은 데이터를 그대로 반환한다.

3. 결과가 웹 브라우저로 반환되고 화면에 표시된다.

